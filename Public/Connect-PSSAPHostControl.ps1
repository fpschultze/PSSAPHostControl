<#
.SYNOPSIS
    Connect to the SAPHostControl web service interface.

.DESCRIPTION
    Returns a saphostcontrol web service proxy object for the given SAP host.

.EXAMPLE
    $saphost = Connect-PSSAPHostControl -ComputerName saphost1 -Credential (Get-Credential)

.OUTPUTS
    SAPHostControl
#>
function Connect-PSSAPHostControl {

    [CmdletBinding()]
    Param (
        [Parameter(Mandatory = $true, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
        [string]
        $ComputerName,

        # Required to call a protected WebMethod.
        [Parameter(Mandatory = $true)]
        [PSCredential]
        $Credential
    )

    Write-EnteringInfo -Invocation $MyInvocation -BoundParameters $PSBoundParameters

    $urlTemplate = 'http://{0}:1128/SAPHostControl/?wsdl'
    $simpleIpRegEx = '\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b'

    $ErrorActionPreference = 'Stop'

    try {

        if ($ComputerName -match $simpleIpRegEx) {

            $fqdnOrIp = [ipaddress]$ComputerName  | Select-Object -ExpandProperty IPAddressToString
        }
        else {

            $fqdnOrIp = [System.Net.Dns]::GetHostByName($ComputerName) | Select-Object -ExpandProperty HostName
        }

        $wsdlUrl = $urlTemplate -f $fqdnOrIp


        #region Connect

        $Result = New-WebServiceProxy -Uri $wsdlUrl -Credential $Credential

        #endregion


        New-Variable -Name PSSAPHostControlEvent -Value ($Result | Get-Member -MemberType Event | Select-Object -ExpandProperty Name) -Scope Script -Force

        # FUTURE? New-Variable -Name PSSAPHostControlLegacyApi -Value $LegacyApi -Scope Script -Force

        # The variables below are a workaround because we had trouble with New-WebServiceProxy's Namespace parameter
        # when we used to connect to multiple SAP hosts successively within a single powershell runspace.
        # Each call of New-WebServiceProxy creates a new autogenerated class. We use these classes now.

        New-Variable -Name PSSAPHostControlNamespace -Value ($Result.GetType().Namespace) -Scope Script -Force

#        Get-Type -Namespace $PSSAPHostControlNamespace -IsEnum | ForEach-Object {
        $PSSAPHostControlNamespace | Get-EnumType | ForEach-Object {

            New-Variable -Name ('PSSAPHostControl{0}' -f $_.Name) -Value $_ -Scope Global -Force
        }

        $returnValue = $Result
    }
    catch {

        Write-Error $_

        $returnValue = $null
    }
    finally {

        Write-LeavingInfo -Invocation $MyInvocation -Result $returnValue

        Write-Output $returnValue
    }
}
